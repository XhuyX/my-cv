var R = Object.defineProperty;
var M = (i) => {
  throw TypeError(i);
};
var P = (i, t, s) => t in i ? R(i, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : i[t] = s;
var T = (i, t, s) => P(i, typeof t != "symbol" ? t + "" : t, s), C = (i, t, s) => t.has(i) || M("Cannot " + s);
var e = (i, t, s) => (C(i, t, "read from private field"), s ? s.call(i) : t.get(i)), d = (i, t, s) => t.has(i) ? M("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, s), n = (i, t, s, a) => (C(i, t, "write to private field"), a ? a.call(i, s) : t.set(i, s), s);
var r, y;
class k {
  constructor(t) {
    d(this, r, "inline");
    d(this, y, (t) => t.parentNode.removeChild(t));
    T(this, "onStart", (t) => {
      this.target || t.target.closest("[data-toast-id]") && (t.preventDefault(), this.target = t.target.closest("[data-toast-id]"), this.targetBCR = this.target.getBoundingClientRect(), this.startX = t.pageX, this.startY = t.pageY, this.currentX = this.startX, this.currentY = this.startY, this.isDragging = !0, this.target.style.willChange = "transform", this.target.style.zIndex = "calc(infinity)");
    });
    T(this, "onMove", (t) => {
      this.target && (e(this, r) === "inline-start" && t.pageX > this.startX || e(this, r) === "inline-end" && t.pageX < this.startX || e(this, r) === "block-start" && t.pageY > this.startY || e(this, r) === "block-end" && t.pageY < this.startY || (this.target.dataset.swiping = "", this.currentX = t.pageX, this.currentY = t.pageY));
    });
    T(this, "onEnd", (t) => {
      if (!this.target) return;
      this.targetX = 0, this.targetY = 0;
      const s = this.currentX - this.startX, a = this.currentY - this.startY, o = e(this, r).includes("inline") ? this.targetBCR.width * 0.3 : this.targetBCR.height * 0.6;
      e(this, r).includes("inline") && Math.abs(s) > o && (this.targetX = s > 0 ? this.targetBCR.width : -this.targetBCR.width), e(this, r).includes("block") && Math.abs(a) > o && (this.targetY = a > 0 ? this.targetBCR.height : -this.targetBCR.height), this.isDragging = !1;
    });
    T(this, "update", () => {
      if (requestAnimationFrame(this.update), !this.target) return;
      this.isDragging ? (e(this, r).includes("inline") && (this.screenX = this.currentX - this.startX), e(this, r).includes("block") && (this.screenY = this.currentY - this.startY)) : (e(this, r).includes("inline") && (this.screenX += (this.targetX - this.screenX) / 4), e(this, r).includes("block") && (this.screenY += (this.targetY - this.screenY) / 4));
      const s = 1 - (e(this, r).includes("inline") ? Math.abs(this.screenX) / this.targetBCR.width : Math.abs(this.screenY) / this.targetBCR.height) ** 3;
      if (this.target.style.setProperty(
        "transform",
        e(this, r).includes("inline") ? `translateX(${this.screenX}px)` : `translateY(${this.screenY}px)`
      ), this.target.style.setProperty("opacity", s), this.isDragging) return;
      const a = Math.abs(e(this, r).includes("inline") ? this.screenX : this.screenY) < 0.1;
      if (s < 0.01) {
        if (!this.target || !this.target.parentNode) return;
        e(this, y).call(this, this.target), this.target = null;
      } else a && this.resetTarget();
    });
    this.targetBCR = null, this.target = null, this.startX = 0, this.startY = 0, this.currentX = 0, this.currentY = 0, this.screenX = 0, this.screenY = 0, this.targetX = 0, this.targetY = 0, this.isDragging = !1, this.direction = (t == null ? void 0 : t.direction) ?? e(this, r), n(this, y, (t == null ? void 0 : t.removeFunction) ?? e(this, y)), this.addEventListeners(), requestAnimationFrame(this.update);
  }
  get direction() {
    return e(this, r);
  }
  set direction(t) {
    console.log("set direction"), n(this, r, t);
  }
  addEventListeners() {
    document.addEventListener("pointerdown", this.onStart), document.addEventListener("pointermove", this.onMove), document.addEventListener("pointerup", this.onEnd);
  }
  resetTarget() {
    this.target && (delete this.target.dataset.swiping, this.target.style.removeProperty("will-change"), this.target.style.removeProperty("z-index"), this.target.style.removeProperty("transform"), this.target.style.removeProperty("opacity"), this.target = null);
  }
}
r = new WeakMap(), y = new WeakMap();
function D(i) {
  "startViewTransition" in document ? document.startViewTransition(i).ready.catch(() => {
  }) : i();
}
var c, X, Y, v;
class B {
  constructor(t, s) {
    d(this, c);
    d(this, X);
    d(this, Y);
    d(this, v);
    n(this, Y, t), n(this, v, s), this.resume();
  }
  resume() {
    e(this, c) || (n(this, X, Date.now()), n(this, c, setTimeout(e(this, Y), e(this, v))));
  }
  pause() {
    e(this, c) && (clearTimeout(e(this, c)), n(this, c, null), n(this, v, e(this, v) - (Date.now() - e(this, X))));
  }
  clear() {
    e(this, c) && (clearTimeout(e(this, c)), n(this, c, null));
  }
}
c = new WeakMap(), X = new WeakMap(), Y = new WeakMap(), v = new WeakMap();
const z = document.createElement("template");
z.innerHTML = `<section data-toast="popover" popover="manual" data-minimized>
  <div data-toast="menubar">
    <button data-toast-button="minimize">Show less</button>
    <button data-toast-button="clear-all">Clear all</button>
  </div>
  <ul data-toast="container"></ul>
</section>`;
const E = document.createElement("template");
E.innerHTML = `<li data-toast="root" role="alertdialog" aria-modal="false" tabindex="0">
  <div data-toast="notification">
    <div data-toast="content" role="alert" aria-atomic="true"></div>
    <div data-toast="actions"></div>
    <button data-toast-button="clear">&times;</button>
  </div>
</li>`;
const I = 6, N = (i, t) => {
  i.innerHTML = t();
}, q = (i) => {
  if (i === "top start") return "block-start inline-start";
  if (i === "top center") return "block-start";
  if (i === "top end") return "block-start inline-end";
  if (i === "bottom start") return "block-end inline-start";
  if (i === "bottom center") return "block-end";
  if (i === "bottom end") return "block-end inline-end";
}, S = (i) => {
  if (i === "top start") return "inline-start";
  if (i === "top center") return "block-start";
  if (i === "top end") return "inline-end";
  if (i === "bottom start") return "inline-start";
  if (i === "bottom center") return "block-end";
  if (i === "bottom end") return "inline-end";
};
var h, p, l, g, u, m, w;
class $ {
  /**
   * @typedef {Object} ToastQueueOptions
   * @property {number} timeout -
   * @property {string} position -
   * @property {string} root -
   */
  constructor(t) {
    d(this, h, /* @__PURE__ */ new Set());
    d(this, p, null);
    /** @type ToastPosition 'top' | 'top center' | 'top end' | 'bottom' | 'bottom center' | 'bottom end' */
    d(this, l, "top end");
    d(this, g, !0);
    d(this, u);
    d(this, m);
    d(this, w);
    n(this, p, (t == null ? void 0 : t.timeout) !== void 0 ? t.timeout : e(this, p)), n(this, l, (t == null ? void 0 : t.position) || e(this, l)), n(this, g, (t == null ? void 0 : t.minimized) || e(this, g));
    const s = (t == null ? void 0 : t.root) || document.body, a = z.content.cloneNode(!0);
    n(this, u, a.querySelector('[data-toast="popover"]')), e(this, u).dataset.toastPosition = e(this, l), n(this, m, a.querySelector('[data-toast="container"]')), s.appendChild(a), n(this, w, new k({
      direction: S(e(this, l)),
      removeFunction: (o) => {
        const f = o.dataset.toastId;
        this.delete(f);
      }
    })), e(this, m).addEventListener("pointerover", (o) => {
      o.target.closest('[data-toast="container"]') && this.pauseAll();
    }), e(this, m).addEventListener("pointerout", (o) => {
      this.resumeAll();
    }), document.addEventListener("visibilitychange", () => {
      document.visibilityState === "hidden" ? this.pauseAll() : this.resumeAll();
    });
  }
  set isMinimized(t) {
    n(this, g, t), this.update();
  }
  get isMinimized() {
    return e(this, g);
  }
  get position() {
    return e(this, l);
  }
  /**
   * @param {string} Toastposition - Toast position
   */
  set position(t) {
    n(this, l, t), e(this, w).direction = S(t), this.update();
  }
  update() {
    e(this, h).size === 1 && e(this, u).showPopover(), e(this, h).size === 0 && e(this, u).hidePopover(), e(this, m).setAttribute("aria-label", `${e(this, h).size} notifications`), D(() => {
      e(this, u).dataset.toastPosition = e(this, l), e(this, g) ? e(this, u).dataset.minimized = "" : delete e(this, u).dataset.minimized, N(e(this, m), () => this.render());
    });
  }
  render() {
    return Array.from(e(this, h)).slice(Math.max(e(this, h).size - I, 0)).reverse().map((s) => {
      const a = E.content.cloneNode(!0), o = s.id, f = `aria-label-${o}`, b = a.querySelector('[data-toast="root"]'), A = a.querySelector('[data-toast="content"]'), L = a.querySelector('[data-toast="actions"]');
      return b.dataset.toastId = o, b.setAttribute("aria-labelledby", f), b.style.setProperty("view-transition-name", `toast-${o}`), b.style.setProperty(
        "view-transition-class",
        `toast ${q(e(this, l))}`
      ), b.style.setProperty("touch-action", "none"), L.innerHTML = s.action ? `<button data-toast-button="action">${s.action.label}</button>` : void 0, A.innerHTML = `${s.content}`, A.setAttribute("id", f), b.outerHTML;
    }).join("");
  }
  get(t) {
    for (const s of e(this, h))
      if (s.id === t)
        return s;
  }
  add(t, s) {
    const a = (s == null ? void 0 : s.timeout) || e(this, p), o = Math.random().toString(36).slice(2), f = {
      id: o,
      index: e(this, h).size + 1,
      timer: a ? new B(() => this.delete(o), a) : void 0,
      content: t,
      action: (s == null ? void 0 : s.action) || void 0
    };
    return e(this, h).add(f), this.update(), f;
  }
  delete(t) {
    for (const s of e(this, h))
      s.id === t && e(this, h).delete(s);
    this.update();
  }
  /** Clear all toasts. */
  clearAll() {
    e(this, h).clear(), this.update();
  }
  /** Pause the timer for all toasts. */
  pauseAll() {
    for (const t of e(this, h))
      t.timer && t.timer.pause();
  }
  /** Resume the timer for all toasts. */
  resumeAll() {
    for (const t of e(this, h))
      t.timer && t.timer.resume();
  }
}
h = new WeakMap(), p = new WeakMap(), l = new WeakMap(), g = new WeakMap(), u = new WeakMap(), m = new WeakMap(), w = new WeakMap();
export {
  $ as ToastQueue
};
